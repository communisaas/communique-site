generator client {
  provider        = "prisma-client-js"
  output          = "../node_modules/.prisma/client"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  avatar    String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // === PRIVACY-PRESERVING VERIFICATION ===
  // NO PII stored per CYPHERPUNK-ARCHITECTURE.md
  // Address verified once via TEE, cached as session credential, then destroyed
  // District stored as hash only (not plaintext)

  // === VERIFICATION FIELDS ===
  is_verified         Boolean   @default(false) @map("is_verified")
  verification_method String?   @map("verification_method")
  verification_data   Json?     @map("verification_data")
  verified_at         DateTime? @map("verified_at")

  // === SYBIL RESISTANCE FIELDS (Phase 1A Identity Verification) ===
  // Privacy-preserving identity verification for duplicate detection
  // See docs/adr/007-identity-schema-migration.md for design rationale
  identity_hash        String? @unique @map("identity_hash") // SHA-256(passport+nationality+birthYear+salt) - Sybil resistance
  identity_fingerprint String? @map("identity_fingerprint") // First 16 chars of hash for audit-safe logging
  birth_year           Int?    @map("birth_year") // Year only for 18+ age verification (NOT full DOB)

  // === CROSS-PROVIDER IDENTITY DEDUPLICATION (ISSUE-001) ===
  // Cryptographic identity commitment from self.xyz/Didit.me verification
  // Used to link multiple OAuth providers to the same verified person
  // When a verified user logs in with a new OAuth provider, accounts are merged
  identity_commitment    String?   @unique @map("identity_commitment")
  identity_commitment_at DateTime? @map("identity_commitment_at")

  // === DOCUMENT TYPE (Wave 14R: authority level differentiation) ===
  // Stored at verification time to differentiate passport (L4) from ID card/license (L3)
  document_type String? @map("document_type") // 'passport' | 'drivers_license' | 'national_id'

  // === USER SECRET DERIVATION (Wave 14b: G-02 Sybil closure) ===
  // Random 32-byte entropy generated once at verification, stored AES-256-GCM encrypted
  // user_secret = Poseidon2(identity_commitment, user_entropy) — derived on-demand, never stored
  encrypted_entropy String? @map("encrypted_entropy") // AES-256-GCM(user_entropy, ENV key)

  // === AUTHORITY LEVEL (Wave 14c: G-03 authority enforcement) ===
  // Derived from verification method + document_type: 1=OAuth, 2=email, 3=ID/license, 4=passport, 5=reserved
  // Stored at verification time, used during ZK proof generation
  authority_level Int @default(1) @map("authority_level")

  // === GRADUATED TRUST (see docs/architecture/graduated-trust.md) ===
  trust_tier Int @default(1) @map("trust_tier")
  // 0=guest(conceptual), 1=authenticated(OAuth), 2=address-attested, 3=ZK-verified, 4=gov-credential

  // === PASSKEY / WEBAUTHN (Tier 1) ===
  passkey_credential_id  String?   @unique @map("passkey_credential_id")
  passkey_public_key_jwk Json?     @map("passkey_public_key_jwk")
  did_key                String?   @unique @map("did_key")
  passkey_created_at     DateTime? @map("passkey_created_at")
  passkey_last_used_at   DateTime? @map("passkey_last_used_at")

  // === ADDRESS ATTESTATION (Tier 2) ===
  address_verification_method String?   @map("address_verification_method") // 'civic_api' | 'postal' | 'mdl'
  address_verified_at         DateTime? @map("address_verified_at")

  // === VERIFICATION RATE LIMITING (Phase 1A) ===
  verification_attempts       Int       @default(0) @map("verification_attempts")
  verification_cooldown_until DateTime? @map("verification_cooldown_until")

  // === CONSOLIDATED WALLET FIELDS (CRITICAL FIX) ===
  wallet_address  String? @unique @map("wallet_address") // Consolidate voter_address + wallet_address
  district_hash   String? @map("district_hash")
  trust_score     Int     @default(0) @map("trust_score")
  reputation_tier String  @default("novice") @map("reputation_tier")

  // === ZERO-KNOWLEDGE VERIFICATION (Phase 1) ===
  district_verified    Boolean   @default(false) @map("district_verified") // ZK proof verification status
  last_proof_timestamp DateTime? @map("last_proof_timestamp") // When last Halo2 proof was generated

  // === SCROLL BLOCKCHAIN ACCOUNT (Deterministic from Passkey) ===
  scroll_address         String? @unique @map("scroll_address") // Derived via NEAR Chain Signatures (deterministic, not PII)
  scroll_derivation_path String? @default("scroll-sepolia,1") @map("scroll_derivation_path")

  // === OPTIONAL EXTERNAL WALLET LINKING ===
  connected_wallet_address String? @unique @map("connected_wallet_address") // MetaMask, WalletConnect, etc
  connected_wallet_type    String? @map("connected_wallet_type") // metamask | walletconnect | coinbase
  connected_wallet_chain   String? @map("connected_wallet_chain") // ethereum | polygon | etc

  // === VOTER PROTOCOL FIELDS ===
  pending_rewards    String?   @map("pending_rewards") // BigInt as string
  total_earned       String?   @map("total_earned") // BigInt as string
  last_certification DateTime? @map("last_certification")
  challenge_score    Int?      @map("challenge_score")
  civic_score        Int?      @map("civic_score")
  discourse_score    Int?      @map("discourse_score")

  // === PHASE 1 REPUTATION FIELDS (Concrete Signals Only) ===
  templates_contributed  Int   @default(0) @map("templates_contributed") // Count
  template_adoption_rate Float @default(0.0) @map("template_adoption_rate") // % of templates others used
  peer_endorsements      Int   @default(0) @map("peer_endorsements") // On-chain attestations
  active_months          Int   @default(0) @map("active_months") // Engagement velocity

  // === PHASE 2 FIELDS (default 0, extend later without rewrites) ===
  challenge_wins   Int @default(0) @map("challenge_wins")
  challenge_losses Int @default(0) @map("challenge_losses")

  // === PHASE 2+ FIELDS (CMS dependency) ===
  response_correlation Float? @map("response_correlation") // % of messages with office responses
  citation_count       Int    @default(0) @map("citation_count") // Congressional citations

  // === PROFILE FIELDS ===
  role                 String?
  organization         String?
  location             String? // General location description (city-level, not PII)
  connection           String?
  profile_completed_at DateTime? @map("profile_completed_at")
  profile_visibility   String    @default("private") @map("profile_visibility")

  // === RELATIONS (keep existing) ===
  account                   account[]
  sessions                  Session[]
  templates                 Template[]
  campaigns                 template_campaign[]        @relation("UserCampaigns")
  template_personalizations template_personalization[]
  source_activations        user_activation[]          @relation("UserSources")
  activations               user_activation[]          @relation("UserActivations")
  representatives           user_representatives[] // Keep this relation

  // === CONSOLIDATED AUDIT SYSTEM ===
  audit_logs    AuditLog[] // Unified audit trail (replaces ReputationLog + CertificationLog)
  civic_actions CivicAction[] // Blockchain-only actions

  // VOTER Protocol challenge relations
  challenger_challenges Challenge[]      @relation("ChallengerChallenges")
  defender_challenges   Challenge[]      @relation("DefenderChallenges")
  won_challenges        Challenge[]      @relation("WonChallenges")
  challenge_stakes      ChallengeStake[]

  // Encrypted identity blob (Phase 1: Postgres, Phase 2: IPFS)
  encrypted_delivery_data EncryptedDeliveryData?

  // === DOMAIN EXPERTISE (Universal Credibility System) ===
  // Flexible, agent-interpreted credentials for any decision-making context
  // Works for Congress, HOAs, universities, corporations, nonprofits
  expertise UserExpertise[]

  // === DISTRICT CREDENTIALS (Tier 2: Address-Attested) ===
  district_credentials DistrictCredential[]

  // === SHADOW ATLAS REGISTRATION ===
  // Zero-knowledge proof generation data (NO PII, only cryptographic metadata)
  shadow_atlas_registration ShadowAtlasRegistration?

  // === IDENTITY VERIFICATION AUDIT (Phase 1A) ===
  // Track verification attempts for fraud detection and compliance
  verification_audits   VerificationAudit[]
  verification_sessions VerificationSession[]

  @@map("user")
}

model Session {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Template {
  id               String  @id @default(cuid())
  slug             String  @unique
  title            String
  description      String
  category         String
  topics           Json?   @default("[]") // Topic tags for search/filtering (1-5 lowercase strings)
  type             String
  deliveryMethod   String  @map("delivery_method")
  preview          String
  message_body     String
  sources          Json?   @default("[]") // Citation sources from message generation agent
  research_log     Json?   @default("[]") @map("research_log") // Agent's research process log
  delivery_config  Json
  cwc_config       Json?
  recipient_config Json
  metrics          Json
  campaign_id      String?
  status           String  @default("draft")
  is_public        Boolean @default(false)

  // Aggregate community metrics (NO individual user tracking)
  verified_sends   Int    @default(0) @map("verified_sends") // Total verified messages sent
  unique_districts Int    @default(0) @map("unique_districts") // Unique districts reached
  avg_reputation   Float? @map("avg_reputation") // Average sender reputation

  // NEW: Semantic embeddings for multi-dimensional search
  location_embedding    Json?     @map("location_embedding") // OpenAI embedding of location context
  topic_embedding       Json?     @map("topic_embedding") // OpenAI embedding of policy topic
  embedding_version     String    @default("v1") @map("embedding_version")
  embeddings_updated_at DateTime? @map("embeddings_updated_at")

  // === STATUS AND TRACKING ===
  verification_status String?   @default("pending") @map("verification_status") // 'pending', 'approved', 'rejected'
  country_code        String?   @default("US") @map("country_code")
  reviewed_at         DateTime? @map("reviewed_at")
  reviewed_by         String?   @map("reviewed_by")

  // === PHASE 1 MODERATION (safety only, NOT quality) ===
  flagged_by_moderation Boolean @default(false) @map("flagged_by_moderation") // OpenAI API flagged
  consensus_approved    Boolean @default(false) @map("consensus_approved") // Multi-agent approved (binary)

  // Reputation impact (Phase 1: on-chain ERC-8004, no token rewards)
  reputation_delta   Float   @default(0) @map("reputation_delta")
  reputation_applied Boolean @default(false) @map("reputation_applied")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // User relationship
  userId String? @map("user_id")
  user   User?   @relation(fields: [userId], references: [id])

  // === EXISTING RELATIONS (preserve all) ===
  template_campaign         template_campaign[]
  template_personalizations template_personalization[]
  activations               user_activation[]
  civic_actions             CivicAction[]

  // NEW: Structured jurisdictions (replaces deprecated string arrays)
  jurisdictions TemplateJurisdiction[]

  // NEW: International geographic scope (agent-extracted, breadcrumb filtering)
  scopes TemplateScope[]

  // NEW: Verifiable messages (pseudonymous, NO user linkage)
  messages Message[]

  @@index([verification_status])
  @@index([country_code])
  @@index([userId])
  @@map("template")
}

// ============= VERIFIABLE MESSAGE MODEL =============
// Per CYPHERPUNK-ARCHITECTURE.md: Messages are PUBLIC, pseudonymous, and verifiable
// NO user_id linkage - can't trace who sent individual messages
// Congressional offices read PUBLIC content + verification proof

model Message {
  id          String @id @default(cuid())
  template_id String @map("template_id")

  // PUBLIC message content (plaintext, readable by offices + moderation)
  content String // Actual message body sent
  subject String? // Email subject (if applicable)

  // CRYPTOGRAPHIC VERIFICATION (stored for later verification)
  verification_proof String @map("verification_proof") // ZK proof of district membership
  district_hash      String @map("district_hash") // SHA-256(district) - NOT plaintext
  reputation_score   Int    @default(0) @map("reputation_score") // Sender's reputation at send time

  // DELIVERY TRACKING (congressional office engagement)
  sent_at              DateTime  @default(now()) @map("sent_at")
  delivered_at         DateTime? @map("delivered_at")
  office_read          Boolean   @default(false) @map("office_read")
  office_responded     Boolean   @default(false) @map("office_responded")
  office_response_time Int?      @map("office_response_time") // Minutes from delivery to response

  // DELIVERY METADATA
  delivery_method   String  @map("delivery_method") // 'cwc' | 'email'
  cwc_submission_id String? @map("cwc_submission_id")
  delivery_status   String  @default("pending") @map("delivery_status") // 'pending', 'delivered', 'failed'
  error_message     String? @map("error_message")

  // Relation to template (aggregates community metrics)
  template Template @relation(fields: [template_id], references: [id], onDelete: Cascade)

  @@index([template_id])
  @@index([district_hash])
  @@index([sent_at])
  @@index([delivery_status])
  @@index([office_read])
  @@map("message")
}

// NEW: Structured jurisdictions for templates (replaces string arrays)
// Enables semantic search, VPN-resistant location matching, and privacy-preserving template discovery
model TemplateJurisdiction {
  id                String @id @default(cuid())
  template_id       String @map("template_id")
  jurisdiction_type String @map("jurisdiction_type") // 'federal' | 'state' | 'county' | 'city' | 'school_district'

  // Federal jurisdictions
  congressional_district String? @map("congressional_district") // "TX-18", "CA-12"
  senate_class           String? @map("senate_class") // "I", "II", "III" (6-year rotation)

  // State jurisdictions
  state_code            String? @map("state_code") // "TX", "CA"
  state_senate_district String? @map("state_senate_district") // State upper house district
  state_house_district  String? @map("state_house_district") // State lower house district

  // County jurisdictions
  county_fips String? @map("county_fips") // 5-digit FIPS code (e.g., "48201" for Harris County, TX)
  county_name String? @map("county_name")

  // City jurisdictions
  city_name String? @map("city_name")
  city_fips String? @map("city_fips") // Census Place FIPS code

  // School district jurisdictions
  school_district_id   String? @map("school_district_id") // NCES district ID
  school_district_name String? @map("school_district_name")

  // Geospatial data (for distance calculations)
  latitude  Float?
  longitude Float?

  // Coverage metadata
  estimated_population BigInt? @map("estimated_population") // Census estimate
  coverage_notes       String? @map("coverage_notes") // Human-readable coverage description

  // Timestamps
  created_at DateTime @default(now()) @map("created_at")
  updated_at DateTime @updatedAt @map("updated_at")

  // Relation to template
  template Template @relation(fields: [template_id], references: [id], onDelete: Cascade)

  // Indexes for efficient querying
  @@index([template_id])
  @@index([jurisdiction_type])
  @@index([congressional_district])
  @@index([state_code])
  @@index([county_fips])
  @@index([city_fips])
  @@index([school_district_id])
  @@map("template_jurisdiction")
}

// ============= INTERNATIONAL GEOGRAPHIC SCOPE (PHASE 1) =============
// Agent-extracted geographic scope for template filtering
// Works internationally: US, UK, France, Japan, Brazil, etc.
// Universal semantic hierarchy: country → region → locality → district

model TemplateScope {
  id          String @id @default(cuid())
  template_id String @map("template_id")

  // UNIVERSAL HIERARCHY (works internationally)
  country_code  String  @map("country_code") // ISO 3166-1 alpha-2: "US", "GB", "FR", "JP", "BR"
  region_code   String? @map("region_code") // "CA" (US), "ENG" (UK), "11" (FR Île-de-France), "13" (JP Tokyo)
  locality_code String? @map("locality_code") // City/municipality FIPS/code
  district_code String? @map("district_code") // Legislative district: "CA-12" (US), "Holborn and St Pancras" (UK)

  // HUMAN-READABLE (agent-extracted, user sees this)
  display_text String @map("display_text") // "California", "CA-12", "London", "São Paulo", "Tokyo"

  // SEMANTIC LEVEL (for filtering, internationally consistent)
  scope_level String @map("scope_level") // 'country' | 'region' | 'locality' | 'district'

  // POWER STRUCTURE CONTEXT (CRITICAL - prevents painful migration later)
  // Open-ended, not an enum - agents can identify any decision-making structure
  power_structure_type String? @map("power_structure_type") // Examples: government, corporate, housing, institutional, labor, nonprofit, advocacy, cooperative, etc.
  audience_filter      String? @map("audience_filter") // Examples: renters, homeowners, workers, residents, shareholders, members, etc.
  scope_notes          String? @map("scope_notes") // Free text for edge cases: "CA-specific corporate policy", "Renters in rent-controlled buildings"

  // AGENT CONFIDENCE (for validation, not just edit affordance)
  confidence        Float   @default(0.8)
  extraction_method String  @default("regex") @map("extraction_method") // 'regex' | 'fuzzy' | 'geocoder' | 'llm' | 'user_confirmed'
  validated_against String? @map("validated_against") // 'ip_location' | 'oauth_location' | 'verified_address' | 'user_edit'

  // OPTIONAL ENRICHMENT
  estimated_reach BigInt? @map("estimated_reach")
  latitude        Float?
  longitude       Float?

  created_at DateTime @default(now()) @map("created_at")
  updated_at DateTime @updatedAt @map("updated_at")

  template Template @relation(fields: [template_id], references: [id], onDelete: Cascade)

  @@index([template_id])
  @@index([country_code, scope_level])
  @@index([country_code, region_code])
  @@index([district_code])
  @@index([power_structure_type])
  @@index([extraction_method])
  @@map("template_scope")
}

model account {
  id                  String   @id
  user_id             String
  type                String
  provider            String
  provider_account_id String
  refresh_token       String?
  access_token        String?
  expires_at          Int?
  token_type          String?
  scope               String?
  id_token            String?
  session_state       String?
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt

  // === SYBIL RESISTANCE: Email Verification Tracking (ISSUE-002) ===
  // Twitter allows accounts without verified email, creating synthetic emails
  // like username@twitter.local. These accounts get lower trust_score to
  // prevent Sybil attacks while still allowing basic functionality.
  email_verified Boolean @default(true) @map("email_verified") // false for synthetic emails (e.g., Twitter without email)

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([provider, provider_account_id])
}

model template_campaign {
  id              String    @id
  template_id     String
  user_id         String
  delivery_type   String
  recipient_id    String?
  cwc_delivery_id String?
  status          String    @default("pending")
  sent_at         DateTime?
  delivered_at    DateTime?
  error_message   String?
  metadata        Json?
  created_at      DateTime  @default(now())
  updated_at      DateTime  @updatedAt
  template        Template  @relation(fields: [template_id], references: [id], onDelete: Cascade)
  user            User      @relation("UserCampaigns", fields: [user_id], references: [id], onDelete: Cascade)
}

model representative {
  id          String  @id @default(cuid())
  bioguide_id String  @unique
  name        String
  party       String
  state       String
  district    String
  chamber     String
  office_code String
  phone       String?
  email       String?

  // === ENHANCED OFFICE INFORMATION (from congressional_office) ===
  member_name    String? @map("member_name") // From congressional_office (may differ from name)
  office_address String? @map("office_address")
  office_city    String? @map("office_city")
  office_state   String? @map("office_state")
  office_zip     String? @map("office_zip")

  // === ENHANCED TERM INFORMATION ===
  term_start   DateTime? @map("term_start")
  term_end     DateTime? @map("term_end")
  current_term Int?      @map("current_term") // Term number

  // === STATUS AND METADATA ===
  is_active    Boolean  @default(true)
  last_updated DateTime @default(now()) @map("last_updated")

  // === DATA SOURCE TRACKING ===
  data_source       String?   @map("data_source") // 'congress_api', 'bioguide', 'manual'
  source_updated_at DateTime? @map("source_updated_at")

  // === RELATIONS (preserve all) ===
  user_representatives user_representatives[]

  @@index([state, district])
  @@index([chamber, is_active])
  @@index([bioguide_id])
  @@index([office_code])
  @@map("representative")
}

model user_representatives {
  id                String         @id @default(cuid())
  user_id           String         @map("user_id")
  representative_id String         @map("representative_id")
  relationship      String
  is_active         Boolean        @default(true)
  assigned_at       DateTime       @default(now()) @map("assigned_at")
  last_validated    DateTime?      @map("last_validated")
  representative    representative @relation(fields: [representative_id], references: [id], onDelete: Cascade)
  user              User           @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, representative_id])
  @@map("user_representatives")
}

model template_personalization {
  id            String   @id @default(cuid())
  user_id       String   @map("user_id")
  template_id   String   @map("template_id")
  variable_name String   @map("variable_name")
  custom_value  String   @map("custom_value") // User-provided customizations (non-PII)
  usage_count   Int      @default(1) @map("usage_count")
  last_used     DateTime @default(now()) @map("last_used")
  created_at    DateTime @default(now()) @map("created_at")
  updated_at    DateTime @updatedAt @map("updated_at")
  template      Template @relation(fields: [template_id], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, template_id, variable_name])
  @@map("template_personalization")
}

model user_activation {
  id                    String   @id @default(cuid())
  user_id               String   @map("user_id")
  template_id           String   @map("template_id")
  source_user_id        String?  @map("source_user_id")
  activation_generation Int      @default(0) @map("activation_generation")
  activation_method     String   @map("activation_method")
  geographic_distance   Float?   @map("geographic_distance")
  activation_time       DateTime @default(now()) @map("activation_time")
  time_to_activation    Float?   @map("time_to_activation")
  cascade_metadata      Json?    @map("cascade_metadata")
  created_at            DateTime @default(now()) @map("created_at")
  source_user           User?    @relation("UserSources", fields: [source_user_id], references: [id])
  template              Template @relation(fields: [template_id], references: [id], onDelete: Cascade)
  user                  User     @relation("UserActivations", fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, template_id])
  @@index([template_id, activation_time])
  @@index([source_user_id, activation_time])
  @@map("user_activation")
}

// ===================================================================
// EXPERIMENTAL RESEARCH TABLES REMOVED (Phase 0.1 Cleanup)
// The following 8 tables were removed as they had zero production usage:
// - political_field_state (field theory simulation)
// - local_political_bubble (echo chamber detection)
// - community_intersection (community overlap analysis)
// - political_dead_end (propagation boundary detection)
// - community_lifecycle (community growth/decline tracking)
// - user_context_stack (sheaf-theoretic user context)
// - political_flow (vector field visualization)
// - political_uncertainty (quantum-inspired persuadability)
//
// See docs/CODEBASE-AUDIT-PHASE-0.md for complete removal documentation
// ===================================================================

model legislative_channel {
  id                    String    @id @default(cuid())
  country_code          String    @unique
  country_name          String
  legislature_name      String
  legislature_type      String
  access_method         String
  access_tier           Int       @default(3)
  email_pattern         String?
  email_domain          String?
  email_format_notes    String?
  api_endpoint          String?
  api_auth_type         String?
  api_documentation_url String?
  rate_limit_requests   Int?
  rate_limit_daily      Int?
  form_url              String?
  form_requires_captcha Boolean   @default(false)
  form_max_length       Int?
  primary_language      String
  supported_languages   String[]
  requires_constituent  Boolean   @default(false)
  requires_real_address Boolean   @default(false)
  forbidden_words       String[]  @default([])
  message_guidelines    String?
  population            BigInt?
  internet_penetration  Float?
  democracy_index       Float?
  is_active             Boolean   @default(true)
  last_verified         DateTime?
  created_at            DateTime  @default(now()) @map("created_at")
  updated_at            DateTime  @updatedAt @map("updated_at")

  @@index([access_tier, is_active])
  @@index([country_code])
  @@map("legislative_channel")
}

// ANALYTICS MODELS (Legacy models removed - see analytics_aggregate for privacy-first replacement)

// =============================================================================
// PRIVACY-FIRST ANALYTICS SCHEMA (Wave 1)
// =============================================================================
// These models REPLACE the legacy analytics_session, analytics_event, and
// analytics_experiment tables. Legacy tables kept temporarily for migration.
// See docs/specs/privacy-first-analytics.md for full specification.

/// Daily aggregate metrics - the ONLY analytics data we store
/// No individual events, no sessions, no user tracking
model analytics_aggregate {
  id String @id @default(cuid())

  // Time bucket (day granularity - never finer)
  date DateTime @db.Date

  // Metric dimensions (empty string = not specified)
  metric          String // e.g., "template_view", "funnel_3", "delivery_success"
  template_id     String @default("") // For template-specific metrics
  jurisdiction    String @default("") // Geographic rollup (district, state, region, national)
  delivery_method String @default("") // For delivery metrics
  utm_source      String @default("") // For acquisition metrics
  error_type      String @default("") // For error metrics

  // The only value we store: a count
  count Int @default(0)

  // Differential privacy metadata
  noise_applied Float @default(0) // Laplace noise applied to count
  epsilon       Float @default(1.0) // Privacy budget consumed

  // Composite unique constraint prevents duplicates
  @@unique([date, metric, template_id, jurisdiction, delivery_method, utm_source, error_type])
  // Query optimization indexes
  @@index([date])
  @@index([metric, date])
  @@index([template_id, date])
  @@index([jurisdiction, date])
  @@map("analytics_aggregate")
}

// =============================================================================
// PRIVACY BUDGET ENFORCEMENT (Wave 2: Differential Privacy)
// =============================================================================
// These models implement a CQRS pattern to prevent "infinite budget" attacks:
//
// WRITE PATH:
//   Raw increments → analytics_aggregate (no noise)
//
// MATERIALIZE PATH (Daily Cron):
//   1. Read raw counts from analytics_aggregate
//   2. Apply Laplace noise ONCE (deterministic seed for auditability)
//   3. Write to analytics_snapshot (immutable after creation)
//   4. Track epsilon spent in privacy_budget
//
// READ PATH:
//   Queries ONLY read from analytics_snapshot (noise already applied)
//   This defeats attacks where repeated queries average out fresh noise
//
// See docs/specs/privacy-first-analytics.md for full specification.
// =============================================================================

/// Pre-noised aggregate data for privacy-preserving queries
/// Noise applied ONCE at materialization, never at query time
/// This defeats "infinite budget" attacks via temporal separation
model analytics_snapshot {
  id String @id @default(cuid())

  // Time bucket (day granularity - never finer)
  snapshot_date DateTime @db.Date

  // Metric dimensions (empty string = not specified)
  metric          String // e.g., "template_view", "funnel_3", "delivery_success"
  template_id     String @default("") // For template-specific metrics
  jurisdiction    String @default("") // Geographic rollup (district, state, region, national)
  delivery_method String @default("") // For delivery metrics
  utm_source      String @default("") // For acquisition metrics
  error_type      String @default("") // For error metrics

  // The noisy count (noise applied once, immutable after creation)
  noisy_count Int

  // Privacy metadata
  epsilon_spent Float // Privacy budget consumed by this snapshot
  noise_seed    String // For auditability - enables deterministic noise reproduction

  created_at DateTime @default(now())

  // Composite unique constraint prevents duplicates
  @@unique([snapshot_date, metric, template_id, jurisdiction, delivery_method, utm_source, error_type])
  // Query optimization indexes
  @@index([snapshot_date])
  @@index([metric, snapshot_date])
  @@index([template_id, snapshot_date])
  @@index([jurisdiction, snapshot_date])
  @@map("analytics_snapshot")
}

/// Daily privacy budget tracking to enforce MAX_DAILY_EPSILON limits
/// Prevents budget exhaustion and tracks query patterns
model privacy_budget {
  id String @id @default(cuid())

  // Budget tracking by day
  budget_date DateTime @unique @db.Date

  // Epsilon accounting
  epsilon_spent Float @default(0) // Total epsilon spent today
  epsilon_limit Float @default(10.0) // Daily limit (configurable)

  // Query tracking
  queries_count Int @default(0) // Number of queries executed

  // Timestamps
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("privacy_budget")
}

// ============= CONSOLIDATED AUDIT SYSTEM (4→2 MODELS) =============
// Enhanced unified audit trail for all user actions

model AuditLog {
  id      String @id @default(cuid())
  user_id String @map("user_id")

  // Core audit classification
  action_type    String  @map("action_type") // 'civic_action', 'reputation_change', 'verification', 'authentication', 'template_action'
  action_subtype String? @map("action_subtype") // 'cwc_message', 'challenge_create', 'score_update', 'login', 'template_submit'

  // Unified audit data (flexible JSONB storage)
  audit_data Json @default("{}") @map("audit_data") // Flexible data storage for any audit type

  // Agent provenance & evidence
  agent_id            String? @map("agent_id") // Which agent verified/acted
  verification_method String? @map("verification_method") // 'zk_proof', 'oauth', 'manual'
  evidence_cid        String? @map("evidence_cid") // IPFS CID for proof

  // Blockchain correlation
  civic_action_id String? @unique @map("civic_action_id")

  // Metadata & status
  status        String  @default("completed") // 'pending', 'completed', 'failed', 'cancelled'
  error_message String? @map("error_message")
  metadata      Json?   @default("{}") @map("metadata")

  // Timestamps
  created_at DateTime @default(now()) @map("created_at")

  // Relations
  user         User         @relation(fields: [user_id], references: [id], onDelete: Cascade)
  civic_action CivicAction? @relation(fields: [civic_action_id], references: [id])

  @@index([user_id])
  @@index([action_type, action_subtype])
  @@index([created_at])
  @@map("audit_log")
}

// ============= VOTER PROTOCOL EXTENSIONS =============
// Blockchain identity and civic action tracking

// Refocused CivicAction: Blockchain-specific only
model CivicAction {
  id      String @id @default(cuid())
  user_id String @map("user_id")

  // Core action identification (minimal, just for blockchain correlation)
  action_type String  @map("action_type") // 'cwc_message', 'template_submit', 'challenge_create'
  template_id String? @map("template_id")

  // === BLOCKCHAIN INTEGRATION ONLY ===
  tx_hash    String? @map("tx_hash") // Scroll zkEVM transaction hash (Ethereum L2)
  reward_wei String? @map("reward_wei") // BigInt as string (VOTER tokens)
  status     String  @default("pending") // 'pending', 'confirmed', 'failed'

  // Blockchain proof & validation
  block_number       Int?    @map("block_number")
  confirmation_count Int?    @map("confirmation_count")
  gas_used           String? @map("gas_used") // BigInt as string

  // Multi-agent consensus for blockchain actions
  consensus_data Json? @map("consensus_data") // Multi-model voting results for rewards

  // Timestamps
  created_at   DateTime  @default(now()) @map("created_at")
  confirmed_at DateTime? @map("confirmed_at")

  // Relations
  user      User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  template  Template? @relation(fields: [template_id], references: [id])
  audit_log AuditLog? // One-to-one with audit trail entry

  @@index([user_id])
  @@index([action_type])
  @@index([status])
  @@index([tx_hash])
  @@index([created_at])
  @@map("civic_action")
}

model Challenge {
  id String @id @default(cuid())

  // Participants (using existing user IDs)
  challenger_id String @map("challenger_id")
  defender_id   String @map("defender_id")

  // Challenge data
  claim_hash    String @unique @map("claim_hash")
  evidence_ipfs String @map("evidence_ipfs")
  stake_amount  String @map("stake_amount") // BigInt as string (VOTER tokens)

  // Status tracking
  status     String  @default("active") // 'active', 'resolved', 'cancelled'
  resolution String? @map("resolution") // 'challenger_wins', 'defender_wins'
  winner_id  String? @map("winner_id")

  // Voting period
  voting_deadline DateTime @map("voting_deadline")

  // Timing
  created_at  DateTime  @default(now()) @map("created_at")
  resolved_at DateTime? @map("resolved_at")

  // Blockchain proof
  creation_tx   String? @map("creation_tx")
  resolution_tx String? @map("resolution_tx")

  // Challenge description
  title       String
  description String
  category    String?

  // Relations
  challenger User             @relation("ChallengerChallenges", fields: [challenger_id], references: [id])
  defender   User             @relation("DefenderChallenges", fields: [defender_id], references: [id])
  winner     User?            @relation("WonChallenges", fields: [winner_id], references: [id])
  stakes     ChallengeStake[]

  @@index([status])
  @@index([created_at])
  @@index([voting_deadline])
  @@map("challenge")
}

model ChallengeStake {
  id           String @id @default(cuid())
  challenge_id String @map("challenge_id")
  user_id      String @map("user_id")

  // Stake details
  amount  String  @map("amount") // BigInt as string
  side    String  @map("side") // 'support', 'oppose'
  claimed Boolean @default(false)

  // Quadratic voting power calculation
  voting_power Float @map("voting_power") // sqrt(amount)

  // Blockchain proof
  stake_tx String? @map("stake_tx")
  claim_tx String? @map("claim_tx")

  created_at DateTime  @default(now()) @map("created_at")
  claimed_at DateTime? @map("claimed_at")

  // Relations
  challenge Challenge @relation(fields: [challenge_id], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [user_id], references: [id])

  @@unique([challenge_id, user_id]) // One stake per user per challenge
  @@index([challenge_id])
  @@index([user_id])
  @@map("challenge_stake")
}

// === MULTI-AGENT CONSENSUS TRACKING ===

model CostTracking {
  id           String   @id @default(cuid())
  date         String   @unique // YYYY-MM-DD format for daily tracking
  totalCost    Float    @default(0) @map("total_cost")
  requestCount Int      @default(0) @map("request_count")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@index([date])
  @@map("cost_tracking")
}

// CWC Job Status Tracking for Async Submissions
model CWCJob {
  id              String    @id @default(cuid())
  templateId      String    @map("template_id")
  userId          String    @map("user_id")
  status          String    @default("queued") // 'queued', 'processing', 'completed', 'partial', 'failed'
  messageIds      Json      @default("[]") @map("message_ids") // SQS message IDs array
  results         Json?     @default("{}") @map("results") // Submission results from Lambda workers
  submissionCount Int       @default(0) @map("submission_count")
  createdAt       DateTime  @default(now()) @map("created_at")
  completedAt     DateTime? @map("completed_at")

  @@index([templateId])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("cwc_job")
}

// ============= ENCRYPTED IDENTITY BLOBS (PHASE 1) =============
// Per PORTABLE-ENCRYPTED-IDENTITY-ARCHITECTURE.md
// Phase 1: Postgres storage (platform cannot decrypt)
// Phase 2: IPFS + on-chain pointers (portable credentials)

model EncryptedDeliveryData {
  id      String @id @default(cuid())
  user_id String @unique @map("user_id")

  // XChaCha20-Poly1305 encrypted blob
  ciphertext           String @map("ciphertext") // Base64-encoded encrypted data
  nonce                String @map("nonce") // Base64-encoded nonce
  ephemeral_public_key String @map("ephemeral_public_key") // Base64-encoded ephemeral key

  // TEE key used for encryption
  tee_key_id String @map("tee_key_id") // Which TEE public key was used

  // Metadata
  encryption_version String    @default("1.0.0") @map("encryption_version")
  created_at         DateTime  @default(now()) @map("created_at")
  updated_at         DateTime  @updatedAt @map("updated_at")
  last_used_at       DateTime? @map("last_used_at") // When blob was last decrypted in TEE

  // User relation
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([created_at])
  @@index([tee_key_id])
  @@map("encrypted_delivery_data")
}

// ============= UNIVERSAL CREDIBILITY SYSTEM =============
// Flexible, agent-interpreted domain expertise for ANY decision-making context
// Works for: Congress, HOAs, universities, corporations, nonprofits, etc.
// Per conversation: "without overengineering this" - same schema works everywhere

model UserExpertise {
  id      String @id @default(cuid())
  user_id String @map("user_id")

  // Domain context (flexible, not rigid enum)
  domain            String // "healthcare" | "hoa_landscaping" | "university_accessibility" | "corporate_supply_chain" | etc.
  organization_type String? @map("organization_type") // "congress" | "hoa" | "university" | "corporate" | "nonprofit"

  // === FREE-TEXT CREDENTIALS (agent parses/verifies) ===
  // No rigid schemas - agents interpret based on domain
  professional_role      String? @map("professional_role") // "Registered Nurse" | "Certified Arborist" | "APICS Supply Chain Manager"
  experience_description String? @map("experience_description") // Free-text backstory, context, relevant experience
  credentials_claim      String? @map("credentials_claim") // "CA RN License #482901" | "ISA Cert #WE-8901A" | "GPC certification"

  // === AGENT VERIFICATION RESULTS ===
  // Agents check state APIs, professional registries, peer networks
  verification_status   String    @default("unverified") @map("verification_status") // "unverified" | "agent_verified" | "state_api_verified" | "peer_endorsed"
  verification_evidence Json?     @map("verification_evidence") // What agent found (API response, registry data, etc.)
  verified_at           DateTime? @map("verified_at")
  verified_by_agent     String?   @map("verified_by_agent") // Which agent verified (openai | gemini | claude | state_api)

  // === CREDIBILITY MULTIPLIERS ===
  // Used for filtering/weighting in decision-maker UIs
  credential_multiplier Float @default(1.0) @map("credential_multiplier") // 1.0 = unverified, 1.5 = peer-endorsed, 2.0 = state-verified

  // === CONCRETE USAGE SIGNALS ===
  // McDonald 2018 research: Staffers value concrete behaviors, not abstract scores
  issues_tracked    String[] @default([]) @map("issues_tracked") // Bill IDs, proposal numbers, resolution codes
  templates_created Int      @default(0) @map("templates_created")
  messages_sent     Int      @default(0) @map("messages_sent")
  peer_endorsements Int      @default(0) @map("peer_endorsements") // Other verified experts vouch for this person
  active_months     Int      @default(0) @map("active_months")

  // === METADATA ===
  is_active    Boolean   @default(true) @map("is_active")
  created_at   DateTime  @default(now()) @map("created_at")
  updated_at   DateTime  @updatedAt @map("updated_at")
  last_used_at DateTime? @map("last_used_at")

  // Relation
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  // Indexes for efficient querying
  @@unique([user_id, domain]) // One expertise record per user per domain
  @@index([user_id])
  @@index([domain])
  @@index([verification_status])
  @@index([credential_multiplier])
  @@index([organization_type])
  @@map("user_expertise")
}

// ============= SHADOW ATLAS INTEGRATION (Phase 1: Zero-Knowledge Proofs) =============
// Per COMMUNIQUE-ZK-IMPLEMENTATION-SPEC.md
// Stores Merkle path and cryptographic metadata for browser-based proof generation
// NO PII stored - address encrypted separately, only proof generation data cached

model ShadowAtlasRegistration {
  id      String @id @default(cuid())
  user_id String @unique @map("user_id")

  // === CRYPTOGRAPHIC IDENTITY ===
  // Identity commitment from self.xyz or Didit.me (Poseidon hash)
  identity_commitment String @map("identity_commitment")

  // === DISTRICT MERKLE TREE METADATA ===
  congressional_district String @map("congressional_district") // "CA-12", "NY-15", etc.
  leaf_index             Int    @map("leaf_index") // Position in district tree (0-16383)
  merkle_root            String @map("merkle_root") // Current root for verification

  // Merkle path for proof generation (14 sibling hashes for 16384-leaf tree)
  merkle_path Json @map("merkle_path") // Array of 14 hex strings

  // === TWO-TREE ARCHITECTURE SUPPORT ===
  // Credential type discriminator (default to single-tree for backward compatibility)
  credential_type String @default("single-tree") @map("credential_type") // 'single-tree' | 'two-tree'

  // Cell-based fields (two-tree only)
  cell_id   String? @map("cell_id") // 15-digit Census GEOID (encrypted at rest)
  districts Json?   @map("districts") // Array of 24 district identifiers

  // Dual Merkle paths (two-tree only)
  user_tree_root     String? @map("user_tree_root") // Root of user identity tree
  user_tree_path     Json?   @map("user_tree_path") // Array of siblings for user tree
  cell_map_root      String? @map("cell_map_root") // Root of cell-to-district SMT
  cell_map_path      Json?   @map("cell_map_path") // Array of siblings for cell map
  cell_map_path_bits Json?   @map("cell_map_path_bits") // Direction bits for SMT traversal

  // === VERIFICATION METADATA ===
  verification_method    String   @map("verification_method") // 'self.xyz' | 'didit'
  verification_id        String   @map("verification_id") // External verification ID
  verification_timestamp DateTime @map("verification_timestamp") // When identity was verified

  // === REGISTRATION STATUS ===
  registration_status String    @default("pending") @map("registration_status") // 'pending' | 'registered' | 'expired'
  registered_at       DateTime? @map("registered_at") // When Shadow Atlas registration completed
  expires_at          DateTime  @map("expires_at") // 6 months from registration

  // === PROOF GENERATION CACHE ===
  // Cached for performance (avoid re-fetching from voter-protocol)
  last_proof_generated_at DateTime? @map("last_proof_generated_at")
  total_proofs_generated  Int       @default(0) @map("total_proofs_generated")

  // === METADATA ===
  created_at DateTime @default(now()) @map("created_at")
  updated_at DateTime @updatedAt @map("updated_at")

  // Relation
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([congressional_district])
  @@index([registration_status])
  @@index([expires_at])
  @@index([credential_type])
  @@map("shadow_atlas_registration")
}

// ============= REMOVED: ShadowAtlasTree (WS1.2) =============
// Local Merkle tree storage removed - now using voter-protocol Shadow Atlas API
// The production API maintains depth-20 trees (1M capacity) which are circuit-compatible
// Previous local implementation used depth-12 trees (4K capacity) which were incompatible
//
// Migration path:
// 1. Drop shadow_atlas_tree table: npx prisma migrate dev --name remove_shadow_atlas_tree
// 2. Existing ShadowAtlasRegistration records remain valid (just store proof data)
// 3. Users re-register to get depth-20 proofs from voter-protocol API

// ============= ZK PROOF SUBMISSIONS (Phase 1: Encrypted Delivery) =============
// Tracks ZK proof submissions for congressional delivery
// Links proof generation → encrypted blob → delivery → on-chain verification

model Submission {
  id              String @id @default(cuid())
  pseudonymous_id String @map("pseudonymous_id") // SHA-256(user_id + SUBMISSION_ANONYMIZATION_SALT) — unlinkable to auth identity
  template_id     String @map("template_id")

  // === ZERO-KNOWLEDGE PROOF DATA ===
  // Browser-generated Halo2 proof (2-5s in TEE)
  proof_hex     String @map("proof_hex") // Serialized proof (hex string)
  public_inputs Json   @map("public_inputs") // [merkle_root, nullifier, action_id]
  nullifier     String @unique @map("nullifier") // Unique per (identity, action) - prevents double-spend
  action_id     String @map("action_id") // Context for the proof

  // === IDEMPOTENCY ===
  // Prevents duplicate submissions from client retries
  idempotency_key String? @unique @map("idempotency_key") // Client-generated unique key

  // === WITNESS ENCRYPTION (XChaCha20-Poly1305) ===
  // Address encrypted to TEE public key, decrypted only in enclave
  encrypted_witness String  @map("encrypted_witness") // Base64-encoded ciphertext
  encrypted_message String? @map("encrypted_message") // Base64-encoded message (optional if public)

  // Encryption Metadata (Optional for Phase 1 MVP if bundled)
  witness_nonce        String? @map("witness_nonce") // Base64-encoded nonce
  ephemeral_public_key String? @map("ephemeral_public_key") // Base64-encoded ephemeral key
  tee_key_id           String? @map("tee_key_id") // Which TEE key was used

  // === CONGRESSIONAL DELIVERY ===
  // CWC API submission (encrypted delivery through TEE)
  cwc_submission_id String?   @map("cwc_submission_id") // CWC API submission ID
  delivery_status   String    @default("pending") @map("delivery_status") // 'pending' | 'processing' | 'delivered' | 'partial' | 'failed'
  delivery_error    String?   @map("delivery_error") // Error message if failed
  delivered_at      DateTime? @map("delivered_at")

  // === BLOCKCHAIN VERIFICATION ===
  // On-chain proof verification (Scroll zkEVM)
  verification_tx_hash String?   @map("verification_tx_hash") // Scroll transaction hash
  verification_status  String    @default("pending") @map("verification_status") // 'pending' | 'verified' | 'rejected'
  verified_at          DateTime? @map("verified_at")
  block_number         Int?      @map("block_number")

  // === REPUTATION TRACKING ===
  // On-chain ERC-8004 reputation update (Phase 1: no token rewards)
  reputation_delta   Int?    @map("reputation_delta") // Reputation change (+5, +10, etc.)
  reputation_tx_hash String? @map("reputation_tx_hash") // Reputation update transaction

  // === WITNESS EXPIRY ===
  // Encrypted witness data auto-expires after 30 days for data minimization.
  // Cleanup cron NULLs out encrypted_witness, witness_nonce, ephemeral_public_key.
  // Proof, nullifier, and delivery status are preserved (not PII).
  witness_expires_at DateTime? @map("witness_expires_at")

  // === METADATA ===
  created_at DateTime @default(now()) @map("created_at")
  updated_at DateTime @updatedAt @map("updated_at")

  @@index([pseudonymous_id])
  @@index([template_id])
  @@index([delivery_status])
  @@index([verification_status])
  @@index([created_at])
  @@index([witness_expires_at])
  @@map("submission")
}

// ============= SUBMISSION RETRY QUEUE (Wave 15a) =============
// Database-backed retry queue for failed blockchain submissions
// Retries with exponential backoff: 30s, 60s, 120s, 240s → give up

model SubmissionRetry {
  id             String   @id @default(cuid())
  submission_id  String   @unique @map("submission_id")
  nullifier      String   @map("nullifier")
  proof_hex      String   @map("proof_hex")
  public_inputs  Json     @map("public_inputs")
  verifier_depth Int      @map("verifier_depth")
  retry_count    Int      @default(0) @map("retry_count")
  next_retry_at  DateTime @map("next_retry_at")
  last_error     String?  @map("last_error")
  status         String   @default("pending") @map("status") // 'pending' | 'succeeded' | 'exhausted'
  created_at     DateTime @default(now()) @map("created_at")
  updated_at     DateTime @updatedAt @map("updated_at")

  @@index([status, next_retry_at])
  @@index([nullifier])
  @@map("submission_retry")
}

// ============= IDENTITY VERIFICATION AUDIT (Phase 1A) =============
// Track all identity verification attempts for fraud detection and compliance
// See docs/adr/007-identity-schema-migration.md for design rationale

model VerificationAudit {
  id                   String   @id @default(cuid())
  user_id              String   @map("user_id")
  method               String // 'self.xyz' | 'didit'
  status               String // 'pending' | 'success' | 'failed' | 'expired'
  failure_reason       String?  @map("failure_reason") // 'age_below_18' | 'duplicate_identity' | 'expired_passport' | 'invalid_proof'
  identity_hash        String?  @map("identity_hash") // Only for successful verifications (helps detect duplicates)
  identity_fingerprint String?  @map("identity_fingerprint") // First 16 chars (audit-safe logging)
  ip_address_hash      String?  @map("ip_address_hash") // SHA-256(IP + daily_salt) for fraud detection
  metadata             Json? // SDK responses (sanitized, no PII)
  created_at           DateTime @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at])
  @@index([identity_hash])
  @@index([status, created_at])
  @@map("verification_audit")
}

// ============= VERIFICATION SESSION (Phase 1A) =============
// Ephemeral sessions for self.xyz and Didit verification flows
// 5-minute expiration prevents replay attacks

model VerificationSession {
  id         String   @id @default(cuid())
  user_id    String   @map("user_id")
  nonce      String   @unique // Cryptographic nonce (prevents replay attacks)
  challenge  String // QR code data / verification challenge
  expires_at DateTime @map("expires_at") // 5-minute expiration (security best practice)
  status     String   @default("pending") // 'pending' | 'verified' | 'expired' | 'failed'
  method     String // 'self.xyz' | 'didit'
  created_at DateTime @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at])
  @@index([expires_at]) // For cleanup job
  @@map("verification_session")
}

// ============= DISTRICT CREDENTIAL (Wave 3A: Address-Attested Tier 2) =============
// Verifiable credential for district residency, issued after address verification
// Supports both Civic API instant verification and postal verification
// Credentials expire and can be revoked; credential_hash enables offline verification

model DistrictCredential {
  id                      String    @id @default(cuid())
  user_id                 String    @map("user_id")
  credential_type         String    @default("district_residency") @map("credential_type")
  congressional_district  String    @map("congressional_district")
  state_senate_district   String?   @map("state_senate_district")
  state_assembly_district String?   @map("state_assembly_district")
  verification_method     String    @map("verification_method") // 'civic_api' | 'postal'
  issued_at               DateTime  @default(now()) @map("issued_at")
  expires_at              DateTime  @map("expires_at")
  revoked_at              DateTime? @map("revoked_at")
  credential_hash         String    @map("credential_hash") // SHA-256 of the VC JSON

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, expires_at])
  @@index([congressional_district])
  @@map("district_credential")
}

// ============= SCOPE CORRECTION LEARNING (EPIC 5: SELF-IMPROVING) =============
// Track user corrections to AI-extracted geographic scope
// System learns from patterns and improves accuracy over time
// Asymptotic approach to 99% accuracy through continuous learning

model ScopeCorrection {
  id          String @id @default(cuid())
  template_id String @map("template_id")

  // AI's original extraction
  ai_extracted  Json   @map("ai_extracted") // Full ScopeMapping
  ai_confidence Float  @map("ai_confidence")
  ai_method     String @map("ai_method") // 'regex' | 'fuzzy' | 'geocoder' | 'llm'

  // User's correction
  user_corrected  Json   @map("user_corrected") // Full ScopeMapping
  correction_type String @map("correction_type") // 'wrong_country' | 'wrong_region' | 'wrong_district' | 'too_broad' | 'too_specific' | 'other'

  // Context for learning
  message_snippet String @map("message_snippet") // First 200 chars
  subject         String

  created_at DateTime @default(now()) @map("created_at")

  @@index([ai_method, correction_type])
  @@index([created_at])
  @@index([template_id])
  @@map("scope_correction")
}

// ============= DISTRIBUTED RATE LIMITING (Postgres-Based) =============
// Multi-instance rate limiting using existing Neon Postgres
// See docs/architecture/rate-limiting.md for design rationale
//
// WHY NOT REDIS:
// - Single person maintaining, operational overhead matters
// - Neon Postgres already available (zero additional cost)
// - For DP contribution limits, approximate enforcement is acceptable
// - Privacy guarantees come from DP noise, not exact rate limits
//
// USAGE:
// - Analytics contribution limits (MAX_DAILY_CONTRIBUTIONS per identifier)
// - API rate limiting for sensitive endpoints
// - Template submission throttling
//
// CLEANUP:
// - Daily cron job deletes entries older than 2 days
// - See src/routes/api/cron/cleanup-rate-limits for implementation

model RateLimit {
  id String @id @default(cuid())

  // Composite key: identifier (hashed IP) + metric type
  key String // Format: "sha256(ip):metric_name" or "sha256(ip):endpoint"

  // Time window (day granularity for daily limits)
  window_start DateTime @map("window_start") @db.Date

  // Counter (incremented atomically via upsert)
  count Int @default(1)

  // Timestamps
  created_at DateTime @default(now()) @map("created_at")
  updated_at DateTime @updatedAt @map("updated_at")

  // Composite unique constraint for upsert
  @@unique([key, window_start])
  // Index for cleanup queries (delete old windows)
  @@index([window_start])
  @@map("rate_limits")
}

// ============================================================================
// Intelligence (migrated from MongoDB — pgvector for embeddings)
// ============================================================================

model Intelligence {
  id               String                       @id @default(cuid())
  category         String // 'news' | 'legislative' | 'regulatory' | 'corporate' | 'social'
  title            String
  source           String
  source_url       String
  published_at     DateTime
  snippet          String
  topics           String[] // Postgres array
  entities         String[] // Postgres array
  embedding        Unsupported("vector(1024)")?
  relevance_score  Float?
  sentiment        String? // 'positive' | 'negative' | 'neutral' | 'mixed'
  geographic_scope String?
  created_at       DateTime                     @default(now())
  expires_at       DateTime?

  // Full-text search: generated tsvector column added via raw SQL migration
  // Indexes: HNSW on embedding, GIN on tsvector, GIN on topics — added via raw SQL

  @@index([category])
  @@index([published_at])
  @@index([relevance_score])
  @@index([expires_at])
  @@map("intelligence")
}

// ============================================================================
// Parsed Document Cache (migrated from MongoDB — JSONB storage)
// ============================================================================

model ParsedDocumentCache {
  id               String    @id @default(cuid())
  source_url       String
  source_url_hash  String    @unique
  document_type    String // 'legislative' | 'official' | 'media' | 'corporate' | 'academic'
  document         Json // Full ParsedDocument as JSONB
  created_at       DateTime  @default(now())
  updated_at       DateTime  @updatedAt
  expires_at       DateTime
  hit_count        Int       @default(0)
  last_accessed_at DateTime?

  @@index([source_url])
  @@index([document_type])
  @@index([expires_at])
  @@map("parsed_document_cache")
}

// ============================================================================
// Agent Trace — Persists agent thoughts, completions, and costs
// ============================================================================

model AgentTrace {
  id         String   @id @default(cuid())
  traceId    String   @map("trace_id")
  userId     String?  @map("user_id")
  endpoint   String
  eventType  String   @map("event_type")
  payload    Json     @default("{}")
  success    Boolean?
  durationMs Int?     @map("duration_ms")
  costUsd    Float?   @map("cost_usd")
  createdAt  DateTime @default(now()) @map("created_at")
  expiresAt  DateTime @map("expires_at")

  @@index([traceId])
  @@index([userId, createdAt])
  @@index([endpoint, createdAt])
  @@index([eventType, createdAt])
  @@index([expiresAt])
  @@map("agent_trace")
}

// ============================================================================
// Resolved Contact Cache — Persists email discoveries across pipeline runs
// 14-day TTL. Keyed on normalized org + title for upsert.
// ============================================================================

model ResolvedContact {
  id          String   @id @default(cuid())
  orgKey      String   @map("org_key")
  name        String?
  title       String?
  email       String?
  emailSource String?  @map("email_source")
  resolvedAt  DateTime @default(now()) @map("resolved_at")
  expiresAt   DateTime @map("expires_at")

  @@unique([orgKey, title])
  @@index([expiresAt])
  @@map("resolved_contact")
}
