<script lang="ts">
	/// <reference types="dom" />
	import { Mail, Sparkles, User, Edit3 } from '@lucide/svelte';
	import { onMount } from 'svelte';
	import { browser } from '$app/environment';
	// import { fade, fly, scale } from 'svelte/transition';
	import AnimatedPopover from '$lib/components/ui/AnimatedPopover.svelte';
	import VerificationBadge from '$lib/components/ui/VerificationBadge.svelte';
	import type { Template } from '$lib/types/template';
	import { popover as popoverStore } from '$lib/stores/popover.svelte';
	import { coordinated, useTimerCleanup } from '$lib/utils/timerCoordinator';
	import { resolveTemplate } from '$lib/utils/templateResolver';
	import { toEmailServiceUser } from '$lib/types/user';

	let {
		preview,
		template = undefined,
		user = null,
		context = 'list',
		onScroll,
		onscrollStateChange,
		ontouchStateChange,
		onvariableSelect,
		onvariableChange,
		expandToContent = false
	}: {
		preview: string;
		template?: Template | undefined;
		user?: {
			id: string;
			name: string | null;
			email?: string;
			street?: string;
			city?: string;
			state?: string;
			zip?: string;
			is_verified?: boolean;
			verification_method?: string;
			representatives?: Array<{
				name: string;
				party: string;
				chamber: 'house' | 'senate' | string;
				state: string;
				district: string;
			}>;
		} | null;
		context?: 'list' | 'page' | 'modal';
		onScroll: (isAtBottom: boolean, scrollProgress?: number) => void;
		onscrollStateChange?: (scrollState: unknown) => void;
		ontouchStateChange?: (touchState: unknown) => void;
		onvariableSelect?: (__event: { variableName: string; active: boolean }) => void;
		onvariableChange?: (__event: { name: string; value: string }) => void;
		expandToContent?: boolean;
	} = $props();
	let scrollContainer: HTMLDivElement;
	let isAtTop = $state(true);
	let isAtBottom = $state(false);
	let isScrollable = $state(false);
	let variableValues: Record<string, string | null> = $state({});

	// Define which variables are system-populated vs user-editable
	// Based on templateResolver.ts - these get auto-filled with user data
	const systemVariables = new Set([
		'Name',
		'Your Name',
		'Address',
		'Your Address',
		'City',
		'State',
		'ZIP',
		'Zip Code',
		'Representative Name',
		'Rep Name',
		'Representative',
		'Senator Name',
		'Senator',
		'Senior Senator',
		'Junior Senator'
	]);

	// These require user input and remain editable
	const userEditableVariables = new Set([
		'Personal Connection',
		'Phone',
		'Phone Number',
		'Your Phone',
		'Your Story',
		'Your Experience',
		'Personal Story'
	]);

	// Use centralized template resolver for comprehensive variable resolution
	const resolvedTemplate = $derived(() => {
		if (!template) return { body: preview };

		// Convert user to EmailServiceUser format if available
		const emailServiceUser = user ? toEmailServiceUser(user) : null;

		try {
			// Use preserveVariables option to keep variables for interactive display
			return resolveTemplate(template, emailServiceUser, { preserveVariables: true });
		} catch (error) {
			console.warn('Template resolution failed, falling back to preview:', _error);
			return { body: preview };
		}
	});

	// For variable parsing, use the original template text (not resolved)
	// This ensures we can create interactive buttons for all variables
	const originalTemplateText = $derived(() => {
		if (template) {
			return template.message_body || template.preview || preview;
		}
		return preview;
	});

	// For display, we'll show a hybrid: resolved text with interactive variable buttons
	// where variables still exist in the original template
	const _resolvedPreview = $derived(resolvedTemplate().body);

	// Contextual hints and suggestions
	const variableHints: Record<string, { prompt: string; placeholder: string }> = {
		'Personal Connection': {
			prompt: 'Personal Connection',
			placeholder: 'Share why this issue matters to you - your story, reasoning, or perspective...'
		}
	};

	const systemVariableHints: Record<string, { title: string; description: string }> = {
		Name: {
			title: 'Your Profile Name',
			description: 'This will be replaced with your name from your profile.'
		},
		'Your Name': {
			title: 'Your Profile Name',
			description: 'This will be replaced with your name from your profile.'
		},
		Address: {
			title: 'Your Full Address',
			description: 'This will be replaced with your complete address from your profile.'
		},
		'Your Address': {
			title: 'Your Full Address',
			description: 'This will be replaced with your complete address from your profile.'
		},
		City: {
			title: 'Your City',
			description: 'This will be replaced with your city from your profile.'
		},
		State: {
			title: 'Your State',
			description: 'This will be replaced with your state from your profile.'
		},
		ZIP: {
			title: 'Your ZIP Code',
			description: 'This will be replaced with your ZIP code from your profile.'
		},
		'Zip Code': {
			title: 'Your ZIP Code',
			description: 'This will be replaced with your ZIP code from your profile.'
		},
		'Representative Name': {
			title: 'Auto-filled Variable',
			description: "This will be replaced with your representative's name based on your address."
		},
		'Rep Name': {
			title: 'Auto-filled Variable',
			description: "This will be replaced with your representative's name based on your address."
		},
		Representative: {
			title: 'Auto-filled Variable',
			description: "This will be replaced with your representative's title and name."
		},
		'Senator Name': {
			title: 'Auto-filled Variable',
			description: "This will be replaced with your senator's name based on your address."
		},
		Senator: {
			title: 'Auto-filled Variable',
			description: "This will be replaced with your senator's title and name."
		},
		'Senior Senator': {
			title: 'Auto-filled Variable',
			description: "This will be replaced with your state's senior senator."
		},
		'Junior Senator': {
			title: 'Auto-filled Variable',
			description: "This will be replaced with your state's junior senator."
		}
	};

	interface Segment {
		type: 'text' | 'variable';
		content: string;
		name?: string;
		instanceId?: string;
	}

	interface DismissStateEvent {
		isDismissing: boolean;
	}

	let modalDismissing = false;

	// Component ID for timer coordination
	const componentId = 'message-preview-' + Math.random().toString(36).substring(2, 15);

	// Parse template content into segments
	function parseTemplate(text: string): Segment[] {
		const segments: Segment[] = [];
		let currentIndex = 0;
		const variablePattern = /\[(.*?)\]/g;
		let match: RegExpExecArray | null;
		const instanceCounts = new Map<string, number>();

		while ((match = variablePattern.exec(text)) !== null) {
			// Add text before variable if exists
			if (match.index > currentIndex) {
				segments.push({
					type: 'text',
					content: text.slice(currentIndex, match.index)
				});
			}

			// Track instances of each variable type
			const variableName = match[1];
			const currentCount = instanceCounts.get(variableName) || 0;
			const instanceNumber = currentCount + 1;
			instanceCounts.set(variableName, instanceNumber);

			// Add variable with unique instance ID
			segments.push({
				type: 'variable',
				name: variableName,
				content: match[0],
				instanceId: `${variableName}-${instanceNumber}`
			});

			currentIndex = match.index + match[0].length;
		}

		// Add remaining text if exists
		if (currentIndex < text.length) {
			segments.push({
				type: 'text',
				content: text.slice(currentIndex)
			});
		}

		return segments;
	}

	// Parse segments from original template to ensure variables are detected
	// Then render them with resolved content where appropriate
	const templateSegments = $derived(parseTemplate(originalTemplateText()));

	// Get resolved values for variables from the template resolver
	const resolvedValues = $derived(
		(() => {
			const emailServiceUser = user ? toEmailServiceUser(user) : null;

			// Create a map of variable name to resolved value
			const resolvedValues: Record<string, string | null> = {};

			if (emailServiceUser) {
				// These match the replacements in templateResolver.ts
				resolvedValues['Name'] = emailServiceUser.name || '';
				resolvedValues['Your Name'] = emailServiceUser.name || '';
				resolvedValues['Address'] =
					emailServiceUser.street &&
					emailServiceUser.city &&
					emailServiceUser.state &&
					emailServiceUser.zip
						? `${emailServiceUser.street}, ${emailServiceUser.city}, ${emailServiceUser.state} ${emailServiceUser.zip}`
						: null;
				resolvedValues['Your Address'] = resolvedValues['Address'];
				resolvedValues['City'] = emailServiceUser.city || null;
				resolvedValues['State'] = emailServiceUser.state || null;
				resolvedValues['ZIP'] = emailServiceUser.zip || null;
				resolvedValues['Zip Code'] = emailServiceUser.zip || null;

				// Representative values
				if (emailServiceUser.representatives && emailServiceUser.representatives.length > 0) {
					const primaryRep =
						emailServiceUser.representatives.find((r) => r.chamber === 'house') ||
						emailServiceUser.representatives[0];
					if (primaryRep) {
						resolvedValues['Representative Name'] = primaryRep.name;
						resolvedValues['Rep Name'] = primaryRep.name;
						resolvedValues['Representative'] = `Rep. ${primaryRep.name}`;
					}

					const senators = emailServiceUser.representatives.filter((r) => r.chamber === 'senate');
					if (senators.length > 0) {
						resolvedValues['Senator Name'] = senators[0].name;
						resolvedValues['Senator'] = `Sen. ${senators[0].name}`;
					}
					if (senators.length > 1) {
						resolvedValues['Senior Senator'] = `Sen. ${senators[0].name}`;
						resolvedValues['Junior Senator'] = `Sen. ${senators[1].name}`;
					}
				} else {
					// Default values when no representative data
					resolvedValues['Representative Name'] = 'Representative';
					resolvedValues['Rep Name'] = 'Representative';
					resolvedValues['Representative'] = 'Representative';
					resolvedValues['Senator Name'] = 'Senator';
					resolvedValues['Senator'] = 'Senator';
					resolvedValues['Senior Senator'] = 'Senior Senator';
					resolvedValues['Junior Senator'] = 'Junior Senator';
				}
			}

			return resolvedValues;
		})()
	);

	// Initialize variable values when segments change
	$effect(() => {
		const segments = templateSegments;
		console.log('🔧 Initializing variable values:', {
			segmentCount: segments.length,
			variables: segments
				.filter((s) => s.type === 'variable')
				.map((s) => ({ name: s.name, type: s.type })),
			currentValues: variableValues
		});
		if (Object.keys(variableValues).length === 0) {
			for (const segment of segments) {
				if (segment.type === 'variable' && segment.name) {
					// For user-editable variables, default to null so button shows [Variable Name]
					// For system variables, use resolved values
					if (userEditableVariables.has(segment.name)) {
						variableValues[segment.name] = null;
						console.log(`Set user-editable variable ${segment.name} to null`);
					} else {
						// Use resolved value or null to show [Variable Name]
						const resolvedValue = resolvedValues[segment.name];
						// Only use resolved value if it's not empty
						variableValues[segment.name] =
							resolvedValue && typeof resolvedValue === 'string' && resolvedValue.trim() !== ''
								? resolvedValue
								: null;
						console.log(`Set system variable ${segment.name} to:`, variableValues[segment.name]);
					}
				}
			}
		}
	});

	onMount(() => {
		const handleDismissState = (e: CustomEvent<DismissStateEvent>) => {
			modalDismissing = e.detail.isDismissing;
		};

		const handleTouchEnd = () => {
			if (modalDismissing) {
				modalDismissing = false;
			}
		};

		document.addEventListener('dismissStateChange', handleDismissState as (event: Event) => void);
		document.addEventListener('touchend', handleTouchEnd);

		return () => {
			document.removeEventListener(
				'dismissStateChange',
				handleDismissState as (event: Event) => void
			);
			document.removeEventListener('touchend', handleTouchEnd);
			useTimerCleanup(componentId)();
		};
	});

	function updateScrollState() {
		if (!scrollContainer) return;

		const { scrollHeight, clientHeight, scrollTop } = scrollContainer;
		isScrollable = scrollHeight > clientHeight;
		isAtTop = scrollTop <= 0;
		isAtBottom = Math.abs(scrollHeight - clientHeight - scrollTop) < 1;

		const detail = {
			isScrollable,
			isAtTop,
			isAtBottom,
			scrollProgress: scrollTop / (scrollHeight - clientHeight)
		};
		// Dispatch custom event so modal can intercept
		scrollContainer.dispatchEvent(new CustomEvent('scrollStateChange', { detail, bubbles: true }));
		onscrollStateChange?.(detail);
	}

	function handleScroll() {
		updateScrollState();
		onScroll(isAtBottom);

		// Close any open popovers when scrolling
		if (popoverStore.popover) {
			popoverStore.close(popoverStore.popover.id);
		}
	}

	let touchStartY = 0;

	function handleTouchStart(__event: TouchEvent) {
		touchStartY = __event.touches[0].clientY;
		handleTouch(__event);
	}

	function handleTouch(__event: TouchEvent) {
		if (!scrollContainer) return;

		const { scrollTop, scrollHeight, clientHeight } = scrollContainer;
		const touchY = __event.touches[0].clientY;

		const touchState = {
			touchY,
			touchStartY,
			isScrollable: scrollHeight > clientHeight,
			isAtTop: scrollTop <= 0,
			isAtBottom: Math.abs(scrollHeight - clientHeight - scrollTop) < 1,
			scrollPosition: scrollTop,
			maxScroll: scrollHeight - clientHeight,
			isDismissing: modalDismissing
		};

		if (
			!modalDismissing &&
			touchState.isScrollable &&
			!(
				(touchState.isAtTop && touchY > touchStartY) ||
				(touchState.isAtBottom && touchY < touchStartY)
			)
		) {
			__event.stopPropagation();
		}

		// Dispatch custom event so modal can adjust gesture handling
		scrollContainer.dispatchEvent(
			new CustomEvent('touchStateChange', { detail: touchState, bubbles: true })
		);
		ontouchStateChange?.(touchState);
	}

	function handleTouchEnd() {
		if (modalDismissing) {
			modalDismissing = false;
		}
	}

	function handleVariableClick(variableName: string) {
		// The popover handles opening/closing automatically
		// We just need to notify the parent component
		if (userEditableVariables.has(variableName)) {
			onvariableSelect?.({ variableName: variableName, active: true });
		}
	}

	function handleInput(e: Event, name: string) {
		const target = e.target as HTMLInputElement | HTMLTextAreaElement;
		variableValues[name] = target.value;

		// Bubble variable changes up to parent for JS-land template updates
		onvariableChange?.({ name, value: target.value });

		// Automatically resize textarea
		if (target.tagName.toLowerCase() === 'textarea') {
			target.style.height = 'auto';
			target.style.height = `${target.scrollHeight}px`;
		}

		// No heuristics here – personalization is purely user-driven.
	}

	$effect(() => {
		if (browser && preview) {
			coordinated.setTimeout(
				() => {
					updateScrollState();
				},
				0,
				'dom',
				componentId
			);
		}
	});

	// Update variable styling with more delightful interactions
	function getVariableClasses(variableName: string): string {
		const isSystemVariable = systemVariables.has(variableName);
		const isUserEditable = userEditableVariables.has(variableName);
		const isEmpty =
			!variableValues[variableName] ||
			(typeof variableValues[variableName] === 'string' &&
				variableValues[variableName]!.trim() === '');

		if (isSystemVariable) {
			return `
				inline-flex items-center gap-1
				px-1 py-0.5 rounded-sm
				font-mono text-xs leading-none
				transition-colors duration-150
				bg-emerald-50 text-emerald-700 ring-1 ring-emerald-200
				cursor-default align-baseline
			`;
		} else if (isUserEditable) {
			const baseClasses = `
				inline-flex items-center gap-1
				px-1 py-0.5 rounded-sm
				font-mono text-xs leading-none
				cursor-pointer transition-all duration-150
				align-baseline transform
			`;

			if (isEmpty) {
				return (
					baseClasses +
					' bg-purple-50 text-purple-700 ring-1 ring-purple-200 hover:bg-purple-100 hover:ring-purple-300'
				);
			} else {
				return (
					baseClasses +
					' bg-participation-primary-50 text-participation-primary-700 ring-1 ring-participation-primary-200 hover:bg-participation-primary-100 hover:ring-participation-primary-300'
				);
			}
		} else {
			// Default styling for unknown variables
			return `
				inline-flex items-center
				px-1 py-0.5 rounded-sm
				font-mono text-xs leading-none
				cursor-pointer transition-colors duration-150
				bg-slate-50 text-slate-600 ring-1 ring-slate-200
				align-baseline
			`;
		}
	}
</script>

<div class="relative flex h-full cursor-text flex-col">
	<!-- Subject/Title Header - Hide on template page to avoid duplication -->
	{#if context !== 'page'}
		{#if template?.subject || template?.title}
			<div
				class="mb-3 rounded-md border border-participation-primary-200 bg-participation-primary-50 px-3 py-2"
			>
				<div class="flex items-center justify-between">
					<div
						class="mb-1 flex items-center gap-2 text-xs font-medium text-participation-primary-700"
					>
						<Mail class="h-3 w-3" />
						Subject Line
					</div>
					{#if user?.is_verified}
						<VerificationBadge size="sm" />
					{/if}
				</div>
				<div class="text-sm font-medium text-participation-primary-900">
					{template.subject || template.title}
				</div>
			</div>
		{:else}
			<!-- Fallback header when no subject/title -->
			<div class="mb-2 flex shrink-0 items-center gap-2">
				<Mail class="h-4 w-4 shrink-0 text-slate-500" />
				<h3 class="text-sm font-medium text-slate-900 sm:text-base">Message Preview</h3>
				{#if user?.is_verified}
					<VerificationBadge size="sm" />
				{/if}
			</div>
		{/if}
	{/if}

	<div class="relative {expandToContent ? '' : 'flex-1'} min-h-[16rem]">
		<div
			class="styled-scrollbar-track scrollbar-thumb-slate-300 scrollbar-track-slate-100/10 {expandToContent
				? ''
				: 'absolute inset-0 overflow-y-auto'} {expandToContent
				? 'overflow-visible'
				: ''} whitespace-pre-wrap rounded-lg bg-slate-50/70 p-4"
			bind:this={scrollContainer}
			onscroll={expandToContent ? undefined : handleScroll}
			ontouchstart={expandToContent ? undefined : handleTouchStart}
			ontouchmove={expandToContent ? undefined : handleTouch}
			ontouchend={expandToContent ? undefined : handleTouchEnd}
			data-scrollable={expandToContent ? false : isScrollable}
		>
			<div class="min-h-[12rem] font-mono text-sm leading-normal text-slate-600">
				{#each templateSegments as segment}
					{#if segment.type === 'text'}
						{segment.content}
					{:else if segment.name}
						<span class="relative inline-block">
							<AnimatedPopover id={segment.instanceId || ''}>
								{#snippet trigger(_params)}
									<button
										class={getVariableClasses(segment.name || '')}
										onclick={() => handleVariableClick(segment.name || '')}
										aria-label={`Edit ${segment.name} variable`}
										type="button"
									>
										<!-- Always show icon based on variable type -->
										{#if segment.name && systemVariables.has(segment.name)}
											<User class="h-2.5 w-2.5 text-emerald-600" />
										{:else if segment.name && userEditableVariables.has(segment.name)}
											{#if segment.name && variableValues[segment.name]}
												<Edit3 class="h-2.5 w-2.5 text-participation-primary-600" />
											{:else}
												<Sparkles class="h-2.5 w-2.5 text-purple-600" />
											{/if}
										{/if}

										<!-- Always show text - either resolved value or placeholder -->
										<span>
											{#if segment.name && resolvedValues[segment.name]}
												{resolvedValues[segment.name]}
											{:else if segment.name && variableValues[segment.name]}
												{variableValues[segment.name]}
											{:else}
												{segment.name || ''}
											{/if}
										</span>

										<!-- Personalized indicator -->
										{#if segment.name === 'Personal Connection' && segment.name && (variableValues[segment.name] || '').trim().length > 0}
											<span
												class="ml-1 rounded bg-emerald-50 px-1 py-0.5 text-[10px] font-medium text-emerald-700 ring-1 ring-emerald-200"
												>Personalized</span
											>
										{/if}
									</button>
								{/snippet}

								{#snippet children(_props)}
									<!-- User-editable variables with input in popover -->
									{#if segment.name && userEditableVariables.has(segment.name)}
										<div class="mb-2 flex items-center gap-1.5">
											<Sparkles class="h-3 w-3 text-purple-500" />
											<span class="text-[11px] font-medium tracking-tight text-slate-700">
												{(segment.name && variableHints[segment.name]?.prompt) ||
													segment.name ||
													''}
											</span>
										</div>

										{#if segment.name && (segment.name
												.toLowerCase()
												.includes('connection') || segment.name
													.toLowerCase()
													.includes('story') || segment.name.toLowerCase().includes('reasoning'))}
											<textarea
												value={segment.name ? variableValues[segment.name] || '' : ''}
												oninput={(e) => handleInput(e, segment.name || '')}
												placeholder={(segment.name && variableHints[segment.name]?.placeholder) ||
													`Enter your ${segment.name || 'value'}...`}
												class="w-full min-w-[280px] resize-none rounded-lg border border-slate-300 bg-white p-3
														font-sans text-sm focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:ring-opacity-20"
												rows="4"
											></textarea>
											<!-- Character count and encouragement -->
											{#if segment.name && variableValues[segment.name] && typeof variableValues[segment.name] === 'string' && (variableValues[segment.name] as string).length > 10}
												<div class="mt-1 text-xs text-purple-600">
													{(variableValues[segment.name] as string).length} characters • Looking great!
												</div>
											{/if}
										{:else}
											<input
												value={segment.name ? variableValues[segment.name] || '' : ''}
												oninput={(e) => handleInput(e, segment.name || '')}
												placeholder={`Enter ${segment.name || 'value'}...`}
												class="w-full min-w-[240px] rounded-lg border border-slate-300 bg-white px-3 py-2
														font-sans text-sm focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:ring-opacity-20"
											/>
										{/if}
									{/if}

									<!-- System-populated hint popup -->
									{#if segment.name && systemVariables.has(segment.name) && systemVariableHints[segment.name]}
										<div class="mb-1 flex items-center gap-1.5">
											<User class="h-3 w-3 text-emerald-500" />
											<span class="text-[11px] font-medium tracking-tight text-slate-700">
												{segment.name ? systemVariableHints[segment.name]?.title || '' : ''}
											</span>
										</div>
										<p class="text-[11px] leading-tight text-slate-500">
											{segment.name ? systemVariableHints[segment.name]?.description || '' : ''}
										</p>
									{/if}
								{/snippet}
							</AnimatedPopover>
						</span>
					{/if}
				{/each}
			</div>
		</div>
	</div>
</div>
