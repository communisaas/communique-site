/**
 * Certification Service - VOTER Protocol Integration
 *
 * Handles certification of civic actions through VOTER Protocol
 * Called AFTER successful delivery to certify and earn rewards
 *
 * This is a client-safe service that communicates with server-side API endpoints
 */

import type { UnknownRecord } from '$lib/types/any-replacements';

export interface CertificationRequest {
	actionType: 'direct_email' | 'cwc_message' | 'local_action';
	deliveryReceipt: string;
	recipientEmail?: string;
	recipientName?: string;
	subject?: string;
	messageHash: string;
	timestamp: string;
	metadata?: Record<string, unknown>;
}

export interface CertificationResponse {
	success: boolean;
	certificationHash?: string;
	rewardAmount?: number;
	reputationChange?: number;
	error?: string;
}

class CertificationService {
	// Use relative API endpoints that will be handled by SvelteKit's server-side routing
	// This keeps all sensitive configuration on the server side
	private readonly endpoints = {
		certify: '/api/voter-proxy/certify',
		status: '/api/voter-proxy/status',
		receipt: '/api/voter-proxy/receipt'
	};

	/**
	 * Certify a civic action after successful delivery
	 * Calls server-side proxy endpoint to keep API keys secure
	 */
	async certifyAction(
		userAddress: string,
		request: CertificationRequest
	): Promise<CertificationResponse> {
		try {
			const response = await fetch(this.endpoints.certify, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({
					userAddress,
					...request
				})
			});

			if (!response.ok) {
				const _error = await response.text();
				console.error('Error occurred');
				return {
					success: false,
					error: `Certification failed: ${response.status}`
				};
			}

			const data = await response.json();
			return data;
		} catch {
			console.error('Error occurred');
			// Don't block delivery on certification failure
			return {
				success: false,
				error: error instanceof Error ? error.message : 'Certification network error'
			};
		}
	}

	/**
	 * Check certification status
	 * Calls server-side proxy endpoint
	 */
	async getStatus(certificationHash: string): Promise<UnknownRecord | null> {
		try {
			const response = await fetch(`${this.endpoints.status}/${certificationHash}`);

			if (!response.ok) {
				return null;
			}

			return await response.json();
		} catch {
			console.error('Error occurred');
			return null;
		}
	}

	/**
	 * Submit delivery receipt for verification
	 * Calls server-side proxy endpoint
	 */
	async submitReceipt(
		receipt: string,
		actionType: string,
		metadata?: UnknownRecord
	): Promise<{ verified: boolean; hash?: string }> {
		try {
			const response = await fetch(this.endpoints.receipt, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({
					receipt,
					actionType,
					metadata
				})
			});

			if (!response.ok) {
				return { verified: false };
			}

			const data = await response.json();
			return data;
		} catch {
			console.error('Error occurred');
			return { verified: false };
		}
	}
}

// Export singleton instance
export const certification = new CertificationService();

/**
 * Helper to generate message hash
 */
export function generateMessageHash(recipient: string, subject: string, body: string): string {
	const content = `${recipient}:${subject}:${body}`;
	// Simple hash for now - in production use crypto
	let hash = 0;
	for (let i = 0; i < content.length; i++) {
		const char = content.charCodeAt(i);
		hash = (hash << 5) - hash + char;
		hash = hash & hash;
	}
	return Math.abs(hash).toString(16).padStart(16, '0');
}
